<!DOCTYPE html>
<html lang="en">
<head>
	<base target="_top">
	<meta charset="utf-8-sig">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>DBV-Regionalligen - Saison 2025/2026</title>
	
	<link rel="shortcut icon" type="image/x-icon" href="./images/favicon.ico" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

	<style>
		html, body {
			height: 100%;
			margin-left: 10px;
		}
		.leaflet-container {
			height: 600px;
			width: 500px;
			max-width: 100%;
			max-height: 100%;
		}
		.popup-route {
			font-size: 11px;
			margin: 2px 0;
		}
		.popup-route a {
			color: #0066cc;
			text-decoration: none;
		}
		.popup-route a:hover {
			text-decoration: underline;
		}
	</style>
</head>

<body>
<b style="font-size: large;">DBV-Regionalligen - Saison 2025/2026</b><br />
<div style="font-size: small;">(auf 8 Mannschaften je Gruppe reduziert ggf. um Tabellenletzte)</div>
<div id='map'></div>
<div style="font-size: small;">Hinweis: Marker anklicken liefert Name der Mannschaften + Routen zu anderen Spielorten</div>
&copy; Edi Klein (03.02.2026)

<script>
// Globale Variablen für Distanzmatrix und Links
let distanzMatrix = {};
let linksMatrix = {};

// Erstelle ein benutzerdefiniertes Icon
function createCustomIcon(color) {
    return L.icon({
        iconUrl: './images/poi-icon-' + color + '_33x50.png',
        iconSize: [20, 32],
        iconAnchor: [16.5, 50],
        popupAnchor: [0, -50]
    });
}

// Funktion zum Parsen der Distanzmatrix
function parseDistanzMatrix(csvData) {
    const lines = csvData.trim().split('\n');
    const header = lines[0].split(';').slice(1); // Erste Spalte überspringen (Zeilen-Labels)
    
    const matrix = {};
    
    for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(';');
        const rowId = cols[0]; // Erste Spalte ist die club_id
        matrix[rowId] = {};
        
        for (let j = 1; j < cols.length; j++) {
            const colId = header[j - 1];
            matrix[rowId][colId] = parseFloat(cols[j]) || 0;
        }
    }
    
    return matrix;
}

// Funktion zum Parsen der Links-Matrix
function parseLinksMatrix(csvData) {
    const lines = csvData.trim().split('\n');
    const header = lines[0].split(';').slice(1);
    
    const matrix = {};
    
    for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(';');
        const rowId = cols[0];
        matrix[rowId] = {};
        
        for (let j = 1; j < cols.length; j++) {
            const colId = header[j - 1];
            matrix[rowId][colId] = cols[j] || '';
        }
    }
    
    return matrix;
}

// Funktion zum Erstellen des erweiterten Popup-Textes
function createPopupText(club_id, club_name, region, clubsInSameRegion) {
    let popupText = `<b>${club_name}</b><br /><br />`;
    
    // Debug-Ausgabe
    console.log(`Creating popup for ${club_id} (${club_name})`);
    console.log(`Clubs in region ${region}:`, clubsInSameRegion);
    console.log(`Has distanzMatrix for ${club_id}:`, distanzMatrix[club_id] !== undefined);
    
    // Füge Routen zu allen anderen Vereinen in der gleichen Region hinzu
    const otherClubs = clubsInSameRegion.filter(c => c.club_id !== club_id);
    
    console.log(`Other clubs in region:`, otherClubs.map(c => c.club_id));
    
    // Sortiere nach Distanz
    otherClubs.sort((a, b) => {
        const distA = distanzMatrix[club_id]?.[a.club_id] || 999999;
        const distB = distanzMatrix[club_id]?.[b.club_id] || 999999;
        return distA - distB;
    });
    
    if (otherClubs.length === 0) {
        popupText += `<div style="color: orange;">Keine anderen Vereine in dieser Region gefunden</div>`;
    }
    
    otherClubs.forEach(club => {
        const distance = distanzMatrix[club_id]?.[club.club_id];
        const link = linksMatrix[club_id]?.[club.club_id];
        
        console.log(`Distance ${club_id} -> ${club.club_id}: ${distance}, Link: ${link}`);
        
        if (distance !== undefined) {
            popupText += `<div class="popup-route">`;
            popupText += `${Math.round(distance)} km &rarr; ${club.club_name}`;
            
            if (link && link.trim() !== '') {
                popupText += ` / <a href="${link}" target="_blank">Route</a>`;
            }
            
            popupText += `</div>`;
        } else {
            // Zeige auch Clubs ohne Distanz-Info für Debugging
            popupText += `<div class="popup-route" style="color: red;">`;
            popupText += `? km → ${club.club_name} (keine Distanz)`;
            popupText += `</div>`;
        }
    });
    
    return popupText;
}

// Funktion zum Laden der CSV-Datei und Erstellen von Markern in einer LayerGroup
async function loadMarkers(read_from_stream) {
    let response, response_dist, response_links;
    let data, data_dist, data_links;
    
    if (read_from_stream) {
        response = await fetch('./fetch_geocoordinates.php');
    } else {
        response = await fetch('./hallen-adressen-geo.csv');
        response_dist = await fetch('./distanzmatrix_8er_SAVE.csv');
        response_links = await fetch('./distanzmatrix_links_8er_SAVE.csv');
    }

    // ************************************
    // EINLESEN DER CSV DATEIEN
    // ************************************
    if (response.ok) {
        data = await response.text();
        console.log('Hallen-Adressen geladen');
    } else {
        console.error('Fehler beim Abrufen der CSV-Daten:', response.statusText);
        return;
    }
    
    if (response_dist && response_dist.ok) {
        data_dist = await response_dist.text();
        distanzMatrix = parseDistanzMatrix(data_dist);
        console.log('Distanzmatrix geladen:', distanzMatrix);
    } else {
        console.error('Fehler beim Abrufen der Distanzmatrix:', response_dist?.statusText);
    }
    
    if (response_links && response_links.ok) {
        data_links = await response_links.text();
        linksMatrix = parseLinksMatrix(data_links);
        console.log('Links-Matrix geladen:', linksMatrix);
    } else {
        console.error('Fehler beim Abrufen der Links-Matrix:', response_links?.statusText);
    }

    // ************************************
    // AUFBEREITUNG DER DATEN
    // ************************************
    
    // Erst alle Clubs sammeln und nach Regionen gruppieren
    const clubsByRegion = {
        'S': [],
        'M': [],
        'W': [],
        'N': []
    };
    
    const rows = data.split('\n').slice(1); // Erste Zeile ignorieren (Header)
    
    // Erste Durchlauf: Alle Clubs sammeln
    rows.forEach(row => {
        if (row.trim() === '') return;
        
        const cols = row.split(';');
        const club_id = cols[0];
        const club_name = cols[1];
        const city = cols[2];
        const street = cols[3];
        const latitude = parseFloat(cols[4]);
        const longitude = parseFloat(cols[5]);
        const color = cols[6];
        const region = cols[7]?.trim()[0];
        
        if (region && clubsByRegion[region]) {
            clubsByRegion[region].push({
                club_id,
                club_name,
                city,
                street,
                latitude,
                longitude,
                color,
                region
            });
        }
    });
    
    // Zweiter Durchlauf: Marker mit erweiterten Popups erstellen
    Object.keys(clubsByRegion).forEach(region => {
        clubsByRegion[region].forEach(club => {
            const popupText = createPopupText(
                club.club_id,
                club.club_name,
                club.region,
                clubsByRegion[club.region]
            );
            
            // Marker erstellen
            const marker = L.marker([club.latitude, club.longitude], { 
                icon: createCustomIcon(club.color) 
            });

            // Popup binden
            marker.bindPopup(popupText, {
                maxWidth: 300,
                className: 'custom-popup'
            });

            // Marker zur LayerGroup hinzufügen
            if (overlayMaps[region]) {
                marker.addTo(overlayMaps[region]);
            }
        });
    });
}

// Erstelle LayerGroups
const S_region = L.layerGroup();
const M_region = L.layerGroup();
const W_region = L.layerGroup();
const N_region = L.layerGroup();

// Layer Control Mapping
var overlayMaps = {
    "S": S_region,
    "M": M_region,
    "W": W_region,
    "N": N_region
};

// erhält die Daten wahlweise von csv Datei (= false), oder als Rückgabewert von einer php Datei
const read_from_stream = false; // MUSS jetzt false sein wg. distanzmatrix !!!

// Karte initialisieren
const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
});

const map = L.map('map', {
    center: [51.52, 9.95],
    zoom: 6,
    layers: [osm, S_region, M_region, W_region, N_region]
});

L.control.layers(null, overlayMaps, { collapsed: false }).addTo(map);

// Marker beim Laden der Seite hinzufügen
window.onload = () => loadMarkers(read_from_stream);

</script>

</body>
</html>
